<!DOCTYPE html>
<html lang="cs" dir="ltr" itemtype="http://schema.org/WebPage" itemscope="">
    <head>
    
    
    
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Debugujeme v Node.js | fragaria.cz</title>
    <meta name="author" content="Fragaria s.r.o." />
    <meta name="robots" content="index,follow" />
    <meta name="description" content="Jakožto nově příchozí do světa Node.js jsem se záhy začal zajímat o způsob, jak efektivně ladit kód v Node.js. Donedávna jsem se pohyboval především v prostředí Pythonu, kde jsem byl zvyklý používat pdb. Jaké jsou alternativy pro Node.js? Výpis do konzole Základní způsob ladění, totiž výpis do konzole, lze s úspěchem použít a...">
    <meta name="keywords" content="fragaria, software, vývoj software, webové aplikace, python, javascript, angular, elasticsearch, html, css, debugnodejs" />
    <!-- Favicons -->
    

    <meta property="og:url"           content="https://fragaria.cz/website/blog/2015/05/27/debugujeme-v-nodejs/" />
    <meta property="og:type"          content="website" />
    <meta property="og:title"         content="Debugujeme v Node.js | fragaria.cz" />
    <meta property="og:description"   content="Jakožto nově příchozí do světa Node.js jsem se záhy začal zajímat o způsob, jak efektivně ladit kód v Node.js. Donedávna jsem se pohyboval především v prostředí Pythonu, kde jsem byl zvyklý používat pdb. Jaké jsou alternativy pro Node.js? Výpis do konzole Základní způsob ladění, totiž výpis do konzole, lze s úspěchem použít a..." />

    

    
    <link rel="stylesheet" href="/website/assets/styles.css">
</head>



    <body class="page-container baseline-grid baseline-grid--visible">
        <div class="page-container__inner">
            <div class="sitenav-wrapper content-block">
    <nav class="sitenav" role="navigation" itemscope itemtype="http://schema.org/SiteNavigationElement">
        <img alt="Fragaria.cz" class="sitenav__brand" src="/website/assets/img/strawberry.svg">

        <ul class="sitenav__linkset">
            <li class="sitenav__linkset-item sitenav__linkset-item--fill"><a href="/website/" class="sitenav__link typeset__anchor--nounderline" itemprop="url"><span itemprop="name">Fragaria.cz</span></a></li>
            
                <li class="sitenav__linkset-item "><a href="/website/works/" class="sitenav__link typeset__anchor--nounderline" itemprop="url"><span itemprop="name">Works</span></a></li>
            
                <li class="sitenav__linkset-item "><a href="/website/team/" class="sitenav__link typeset__anchor--nounderline" itemprop="url"><span itemprop="name">Team</span></a></li>
            
                <li class="sitenav__linkset-item sitenav__linkset-item--active"><a href="/website/blog/" class="sitenav__link typeset__anchor--nounderline" itemprop="url"><span itemprop="name">Blog</span></a></li>
            
                <li class="sitenav__linkset-item "><a href="/website/career/" class="sitenav__link typeset__anchor--nounderline" itemprop="url"><span itemprop="name">Career</span></a></li>
            
        </ul>
    </nav>
</div>


            <article itemtype="http://schema.org/BlogPosting" itemscope="">
  <div class="content-block">
    <h1 itemprop="headline">Debugujeme v Node.js</h1>
    <p>Jakožto nově příchozí do světa Node.js jsem se záhy začal zajímat o způsob, jak efektivně ladit kód v Node.js. Donedávna jsem se pohyboval především v prostředí Pythonu, kde jsem byl zvyklý používat <a href="https://docs.python.org/3/library/pdb.html">pdb</a>. Jaké jsou alternativy pro Node.js?</p><a name='more'></a> <h3>Výpis do konzole</h3> <p>Základní způsob ladění, totiž výpis do konzole, lze s úspěchem použít asi v jakémkoliv programovacím jazyce a na jakékoli platformě. Javascript není výjimkou &#8212; <a href="http://www.commonjs.org/">CommonJS</a> definuje modul console, který lze pro výpis použít, typicky asi pomocí funkce <code>console.log</code>.</p>  <p>V případě Node.js je tento modul rovnou dostupný prostřednictvím globální proměnné se stejným názvem (tj. "console"). I když je podle mojí zkušenosti tento způsob debugování dostačující v drtivé většině případů, je natolik jednoduchý, že asi nemá cenu se mu dále věnovat.</p> <h3>Command-line debugger</h3> <p>Node (nebo spíše <a href="https://en.wikipedia.org/wiki/V8_%28JavaScript_engine%29">V8</a>) obsahuje i vlastní plnohodnotný debugger, který podporuje breakpointy, krokování i watchery. <a href="https://nodejs.org/api/debugger.html#debugger_watchers">Dokumentace</a> je, myslím si, docela pěkná, ale i tak zde použití nodovského debuggeru přiblížím.</p> <h4>Jak přistoupit k rozhraní ladícího nástroje</h4> <p>Prvním krokem je spuštění nodovského procesu v debug módu:</p> <pre><code><br />node debug app.js<br /></pre></code> <p>Pokud náhodou používáte <a href="https://github.com/remy/nodemon">nodemon</a> pro automatické načítání změn kódu, i ten lze takto spustit:</p> <pre><code><br />nodemon --debug app.js<br /></pre></code> <p>(Existuje rovněž způsob, jak se připojit k již běžícímu Node.js procesu, který můžete najít ve výše zmíněné dokumentaci.)</p> <p>Vykonávání kódu se zastaví na první řádce (výrazu) vaší aplikace a v terminálu uvidíte rozhraní debuggeru. I když už teď lze krokovat, interaktivně vstupovat do běžícího prostředí a podobně, myslím, že užitečnější je nejdřív definovat breakpointy na místech aplikace, která nás blíže zajímají.</p> <h4>Breakpointy</h4> <p>Řekněme, že máme tuto jednoduchou funkci:</p> <pre><code><br />function foo(bar) {<br />    return bar.reduce(function (curr, prev) {return curr + prev; }, 0);<br />}<br /></pre></code> <p>Dále si představme, že na nějakém místě v naší aplikaci čekáme, že tato funkce vrátí konkrétní číslo, třeba 90. Jenže ouha, vrácené číslo je 89. Nejjednodušší způsob, jak zjistit proč, je podívat se, jaký argument funkce dostává. To můžeme udělat třeba tak, že na vhodné místo umístíme breakpoint:</p> <pre><code><br />function foo(bar) {<br />    debugger; // Definováno v ECMAScript 5.<br />    return bar.reduce(function (curr, prev) {return curr + prev; }, 0);<br />}<br /></pre></code> <p>Po spuštění aplikace v debug módu (a přeskočení úvodního breakpointu pomocí příkazu <code>cont</code>) se vykonávání kódu zastaví na řádce obsahující výraz "debugger". Nyní si můžeme prohlédnout, co vlastně funkce dostává za argumenty:</p> <pre><code><br />break in hele.js:2<br />  1 function foo(bar) {<br />  2     debugger; // Definováno v ECMAScript 5.<br />  3     return bar.reduce(function (curr, prev) {return curr + prev; }, 0);<br />  4 }<br />debug> repl<br />Press Ctrl + C to leave debug repl<br />> bar<br />[ 27, 16, 35, 11 ]<br /></pre></code> <p>Breakpointy můžeme nastavit buď přímo v kódu (jako v příkladu nahoře), nebo v rozhraní běžícího debuggeru pomocí příkazu <code>setBreakpoint</code>. Všimněte si také příkazu <code>repl</code>, který jsme zadali, abychom se následně mohli dotázat na obsah proměnné <code>bar</code>.</p>  <h4>REPL (Read-Eval-Print Loop) během ladění</h4> <p>U předchozího příkladu mohlo někoho napadnout, že jednoduchý výpis do konzole by posloužil stejnému účelu i bez debuggeru &#8212; a měl by pravdu. Faktem nicméně je, že existují výrazně složitější situace, kde jeden výpis nestačí, a pokud vývojář nemá v zásobě jiný trik, většinou končí u mnohokrát opakovaného pouštění aplikace s různými výpisy ve snaze objevit podstatu problému.</p> <p>To je přesně situace, kde se vyplatí použít příkaz <code>repl</code>. Ten umožňuje vstup do interaktivního módu &#8212; vykonávání programu je stále zastaveno na daném místě (breakpointu), ale přitom můžeme v javascriptové konzoli přistupovat ke všem proměnným/objektům dostupným v aktuálním rámci. Objekty můžeme nejen zkoumat, ale i měnit, přičemž změny zůstanou v platnosti i poté, co se program opět rozběhne (příkaz <code>cont</code> debuggeru). Myslím, že je evidentní, o jak mocný nástroj pro ladění se jedná.</p>  <h4>Krokování a watchery</h4> <p>Alternativou k vypisování proměnných nebo k jejich interaktivnímu zkoumání v REPLu je nastavení watcherů spojené s krokováním. Příkazem <code>watch("expression")</code> (např. <code>watch("bar")</code>) můžeme debuggeru říci, aby nám u každého breakpointu (i při každém dalším kroku &#8212; příkazy <code>next</code>, <code>step</code> a <code>out</code>, viz dokumentace) ukázal, jaká je hodnota zadaného výrazu.</p> <p>Výhodou oproti obyčejným výpisům je to, že výraz, který nás zajímá, specifikujeme pouze jednou, a potom už jenom pohodlně sledujeme, jak se mění během průchodu aplikací.</p> <h3>node-inspector</h3> <p>Debugger popsaný v předchozí sekci je užitečný, ale ze zkušenosti vím, že někteří vývojáři považují prostředí příkazové řádky za nekomfortní. Proto bych chtěl zmínit ještě jeden nástroj, který lze při debugování použít. Jedná se o <a href="https://github.com/node-inspector/node-inspector">node-inspector</a> &#8212; npm modul, který umožňuje ladit nodovský kód v Chrome Developer Tools debuggeru.</p> <p>Stačí tento modul nainstalovat (např. <code>npm install -g node-inspector</code>) a následně jej spustit formou <code>node-debug app.js</code>. Výsledkem je, že se spustí aplikace a zároveň se otevře Chrome a jeho debugger. Ten lze použít na všechno, co bylo popsáno v minulé sekci, s plným pohodlím grafického uživatelského rozhraní.</p>  <div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-4tu1uJoUPkc/VWLQzuJptyI/AAAAAAAAAhc/Isv16Hxfbd4/s1600/node_inspector.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-4tu1uJoUPkc/VWLQzuJptyI/AAAAAAAAAhc/Isv16Hxfbd4/s400/node_inspector.png" /></a></div>   <p>Závěrem bych tak snad jen řekl, že se zdá, že ladit kód v Node.js není o nic těžší nebo jednodušší než na jiných platformách. Alespoň do chvíle, než začnete používat <a href="http://www.html5rocks.com/en/tutorials/es6/promises/">Promises</a>, ale o těch snad zase radši někdy příště.</p>
  </div>
</article>

        </div>
    </body>
</html>
